{
  "name": "Webpack Config Assign",
  "tagline": "A utility to merge webpack config(s) (typically separated out by environment)",
  "body": "### webpack-config-assign\r\n\r\n#### What it is\r\n\r\nA utility to merge separate webpack configs (e.g. `webpack.config.prod.js`, `webpack.config.development.js`, etc.) in a smarter way than a simple merge or assign.\r\n\r\n#### What it does\r\n\r\nIt looks at each configuration key passed in (e.g. `plugins`, `module`, `entry`, etc.) and if it can merge it intelligently, the utility attempts to do so. For instance, consider the following scenarios:\r\n\r\n- A development config that inlines CSS into the bundle\r\n- A production config that extracts the CSS out into a separate plugin\r\n- Uglification plugin(s) and other production enhancements only applied in production\r\n\r\nThis plugin is able to intelligently merge each of the above, in essence, in concatenates plugins, and intelligently merges loaders when the `test` matches.\r\n\r\n### How to use\r\n\r\nThe utility can be seamlessly integrated into an existing workflow, particularly one that has already been segmented out into environment configs. However, if using a monolithic `webpack.config.js` with a bunch of environment checks, then some work will need to be done to separate these out into their respective environments/phases.\r\n\r\nConsider the following \"base\" config (configuration that will be shared between dev, test, and/or production). I like to name it `webpack.config.base.js`, but it can just as easily be inlined into `webpack.config.js`:\r\n\r\n```javascript\r\nconst webpack = require('webpack');\r\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\r\n\r\nconst path = require('path');\r\nconst pkg = require(path.resolve('./package.json'));\r\n\r\nmodule.exports = {\r\n  devtool: 'source-map',\r\n  entry: {\r\n    [pkg.name]: [\r\n      './src/index'\r\n    ],\r\n    vendor: Object.keys(pkg.dependencies)\r\n      .filter((dep) => {\r\n        return ['normalize.css'].indexOf(dep) === -1;\r\n      })\r\n  },\r\n  output: {\r\n    filename: '[name].js',\r\n    path: path.join(__dirname, './dist/')\r\n  },\r\n  module: {\r\n    rules: [\r\n      {\r\n        test: /\\.js(x)?$/,\r\n        include: [path.join(__dirname, 'src')],\r\n        use: [\r\n          'react-hot-loader/webpack',\r\n          'babel-loader'\r\n        ]\r\n      },\r\n      {\r\n        test: /\\.css$/,\r\n        use: [\r\n          'style-loader',\r\n          {\r\n            loader: 'css-loader',\r\n            options: {\r\n              importLoaders: 1,\r\n              modules: true\r\n            }\r\n          },\r\n          'postcss-loader'\r\n        ]\r\n      }\r\n    ]\r\n  },\r\n  plugins: [\r\n    new HtmlWebpackPlugin({\r\n      filename: path.join(__dirname, 'dist', 'index.html'),\r\n      inject: 'body',\r\n      template: path.join(__dirname, 'src', 'index.html')\r\n    }),\r\n    new webpack.optimize.CommonsChunkPlugin({\r\n      name: 'vendor',\r\n      minChunks: Infinity\r\n    }),\r\n    new webpack.LoaderOptionsPlugin({\r\n      options: {\r\n        context: __dirname,\r\n        postcss: [\r\n          require('postcss-nested'),\r\n          require('postcss-cssnext')({\r\n            browsers: ['ie >= 9', 'last 2 versions']\r\n          })\r\n        ]\r\n      }\r\n    }),\r\n    new webpack.NoErrorsPlugin(),\r\n    new webpack.NamedModulesPlugin(),\r\n    new webpack.DefinePlugin({\r\n      'process.env': { \r\n         NODE_ENV: JSON.stringify(process.env.NODE_ENV) \r\n       }\r\n    })\r\n  ]\r\n};\r\n```\r\n\r\nthe above is a fairly typical config, and this could be dropped into `webpack.config.js` quite easily. However, what if we want super speedy reload times, webpack-dev-server, and so on and so forth in development. Well, let's create a `webpack.config.development.js`, like so:\r\n\r\n```javascript\r\nconst DashboardPlugin = require('webpack-dashboard/plugin');\r\n\r\nmodule.exports = {\r\n  devtool: 'eval',\r\n  entry: {\r\n    [pkg.name]: [\r\n      'webpack-dev-server/client?http://localhost:3000',\r\n      'webpack/hot/only-dev-server',\r\n      'react-hot-loader/patch',\r\n      './src/index'\r\n    ]\r\n  },\r\n  plugins: [\r\n    new DashboardPlugin()\r\n  ]\r\n};\r\n```\r\n\r\nnow we're cooking. We are using the excellent `webpack-dashboard` plugin, and we're also doing some nice webpack hot reloading with the webpack dev server. Now, let's get to merging those configurations\r\n\r\n```javascript\r\nconst webpackConfigAssign = require('webpack-config-assign');\r\n\r\nconst devConfig = process.env.NODE_ENV === 'development' ? require('./webpack.config.development') : {};\r\n\r\nmodule.exports = webpackConfigAssign(require('./webpack.config.base'), devConfig);\r\n```\r\n\r\nand like that, we're done. Easy as pie! Let's wrap up what specifically happened:\r\n\r\n- Our entry for development will use the webpack-dev-server\r\n - Because the keys match, the `entry[pkg.name]` will be overwritten by the development config, rather than merged\r\n- Our plugins for development are merged/concatenated with our base config\r\n- We have super speedy hot reloads and instant feedback, and an ultra slick dashboard, with little effort and manual intervention\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}